Kotlin emphasizes on:
- conciseness
- safety
- pragmatism
- interoperability with Java

In kotlin, you can write functions outside of class, in Java, you can not
but the truth is, the compiler will then deal with boilerplate code and generate the class under the covers for us
these functions are called top level functions because they are not defined in a class

kotlinc compiles .kt files into .class files than are equivalent to the ones that javac produces and that can be read by the JVM
to run kotlin applications, we need the kotlin runtime library which is something similr in nature to the JRE

the JVM looks for the main(...) method signature to find the entry point of a program
everything is class in kotlin for example Array<String>

Kotlin tries to reduce the amount of code we write
for example, we write println() instead of Systemt.out.println() because kotlin imports from of this stuff from the start
we call this the kotlin standard library
https://kotlinlang.org/api/latest/jvm/stdlib/
it serves the same pupose that the JDK does, it has a bunch of API for you to use

Kotlin is statically types, meaning that all variable types are known at compile time

kotlin: preferes stuff to be immutable than mutable vs Java, where by default, variables are mutable
    val number3: Int
    number3 = 10
    // number3 = 11 => this will throw the error

    var number4: Int
    number4 = 9
    number4 = 12
    // var: value is mutable

val employee = Employee("lynn smith", 500) => no need for "new" keyword
employee.name = "lynn jones"
// employee.id = 5
// val employee can not be assigned a new Employee instance (val), but that does not mean that its member variables
// can not be changed, in this case, the name can be changed (var) but id can not

Type Aliases
============
StringBuilder stringBuilder...
by going to its definition, we see the following
@SinceKotlin("1.1") public actual typealias StringBuilder = java.lang.StringBuilder
=> this means, that when we use StringBuilder in kotlin, we are actually using the java StringBuilder

Custom Aliases can be declared => bet done at file level
declare it: typealias EmployeeSet = Set<Employee>
use it: val employees: EmployeeSet

Some quick diff between Java and Kotlin
---------------------------------------
kotlin does not require semicolons
kotlin has many wrappers around some commonly used Java functions like println and System.out.println
Hard keyowrds: Java and Kotlin => example: int, double, if...
Soft keywords: Kotlin => soft keywords can be redefined where they are not being used to meet their built-in function,
but it is not considered as a good practice

square brakets can be used to access elements in collection instead of .get()
=> this is done in pursuit of more concise code
concise: giving a lot of information clearly and in a few words; brief but comprehensive

Kotlin has its own String class
for example, in Java length is a method (bla.length()) while in kotlin, it is a property

Equalities
----------
in Java:
== => compares instance references
.equals(...) => override to check for structural equality
in Kotlin:
== => differens to the .equals() method
=== => the triple = is what checks for referencial equality
same applies for != and !==

NOTE
----
The difference between == and === is that: == converts the variable values to the same type before performing comparison.
This is called type coercion. === does not do any type conversion (coercion) and returns true only if both values and types
are identical for the two variables being compared

Bitwise operators
val x = 0x00110011
val y = 0x10100011

Java => | & ^
kotlin: or and xor

"is" vs "instanceOf"
!is (not is)

Casting and Smart Casting
-------------------------
to cast in Java: (Employee) something
to cast in kotlin: val newEmp = something as Employee
Kotlin does smart casting, for example:
if (something is Employee){
  kotlin treats the variable as if it has been cast
  so here, inside this block of code, no need to cast something as an Employee
}

Request Templates
-----------------
val change = 4.22
println("to show the value of change we use: \$change and its value is $change (ps: $$change shows the $ sign)")
Values of expressions can be substituted as well (you use ${...}):
- println("division = ${x / y}")
- println("employee id = ${employee.id}")

Raw Strings
-----------
triple quoted
no need to escape characters (i.e it includes new line chracter, can't use \n here)
can be multiline:
"""balbalbalbalbalbalba
lkasdjflkajsdlkfj
asdfasdfasdf"""

the indentation here looks bad, but if we beautify the code, the resulting string will contain the tabs
so we use trimMargin method with a trim margin char of our choosing
bro = """balbalbalbalbalbalba
        *lkasdjflkajsdlkfj
        *asdfasdfasdf""".trimMargin("*")

String templates can also be used inside raw strings

Read Eval and Print Loop: REPL
------------------------------
Go to: Tools -> Kotlin -> REPL
REPL is aware of the declarations in the project
it is like a command line active terminal
you can use it to test some code and evaluate some expressions
it also knows about previous declarations you did in it so,
if you do x = 3 + 4 which results in 7 and reference x later on, you will get the value of 7

Built In Datatypes
------------------
In koltin, everything is a class, no lower case like java
Java: int and Integer
Kotlin: Int

With kotlin, a good practive would be to specify the variable type if it is not being assigned at its declaration
the Datatypes are similar to Java

In Java we can do:
int x = 10;
long xl = x;
=> java widens numbers but kotlin does not
In kotlin we would do:
xl = x.toLong()

Another example:
val myByte: Byte = 111
var myShort: Short
myShort = myByte.toShort()

There is only one exception: Numeric Literals, kotlin wil widen them
val anoterInt = 5

by default, float points are created as double if the type float is no speicified (or use F like L for long)

for Chars, in Java you can do: char x = 65; => the value of x will be the char that maps to 65
in Kotlin, you can not do this. To do use, you use .toChar() => same concept as the others
the Kotlin types compile to Java's primitive types and not the type wrapper classes

Void: in Java a method that returns void actually returns nothing
in koltin, what gets returned is called Unit, Unit is a thing unlike java
Unit => singleton instance

in Koltine there is class called Nothing, which is a subclass of every class
=> use case: function that never returns (has an infinite loop) => this is how we tell the compiler this

Arrays
------
the Array class is a collection class
println(long1[0]) => use array index to get values
you can also use .set and .get

lambda expressions can be used to initialize arrays
val myArr = Array<Int>(16) { i -> i * 2 } // i here is the index

val with arrays: will contain a reference to the array that can not be changed, but contents of the array can be
we can also create mixed type arrays (results in an array on "Any")
when passing arrays to java functions that require primitive arrays: (int[] myArr), you need to use the special Kotlin type arrays
like intArrayOf(...), doubleArrayOf(...)

When dealing with the general array constructor, if you provide the size, you HAVE to provide the values
when dealing with the primitive array constructors, it will be initialized for you

Null Reference in Kotlin
------------------------
kotlin has the notion of nullable type. We use "?" after the variable type
once a variable is nullable, the operations that can be done on it become restricted
certain string methods for example can no longer be called
so get access to it, we do a null check => smart null check like smart casting
OR we use safe access expression str?.length => short hand for null check

if (bankAccount != null) {
    if (bankAccount.country != null){
        if (bankAccount.country.code != null)
            bankAccount.country.code.doSomething()
    }
}

in kotlin, we can do: bankAccount?.country?.code?.doSomething()

=> if one of them is null, it short-circuits and returns null (the expression evaluates to null)

The Elvis Operator "?:" (cz it looks like elvis's hair when his head is tipped on the side)
it lets us assign a default value if an expression evaluates to null

similar to safe access, we have safe casting
val str5 = something as? String
once we have used safe casting, we have the possibility of getting a null, so now we have to use safe access with str5

The NOT NULL assertion: !!
we use this when we are absolutely sure that a variable can NEVER be null
in this case, if the variable ends up as null, we will actually get a null pointer exception
we get a kotlin.KotlinNullPointerException
NOTE: the exception line number in the stack trace appears to be the line where we made the assertion, for example
1) val str: String? = null
2) val str2: str!!
3) val str3: str2.toUpperCase()
=> the exception line number will be "2"
Bad practice, stringing null assertion operator like the safe access operator, the issue here would that
we will only get a line number and the trace will not tell us which of the null assertions failed

For example, we can not pass a nullable variable to a function that is expecting a non-nullable argument
bad practice: myFun(myVar!!)
good practice: use the let function
str?.let {myFun(it)} which is a shorthand for:
if (str != null){
    myFun(str)
}

== is a safe operator
println(str == myString) // no error here even though str can be null, that is because == is a safe operator

creating arrays of nulls:
    val myArrayOfNulls: Array<Int?> = Array(16) { null }
    val myArrayOfNulls2 = arrayOfNulls<Int>(16)

OOP and Kotlin
==============
Access modifiers
----------------
we have 4:
- public, private and protected: like java
- internal => visible inside the module (if inside a private class, then it would only be visible inside the class), so
we would use internal is the variable is accessible from outside the file

In kotlin, classes can not see private members belonging to inner classes
private (kotlin) -> compiled to package private
internal (kotlin) -> compiled to public

The default visibility in Java is package private, but in kotlin, it is public

In java, the top level is always a class, but in kotlin, we can have variables and functions
If an item at the top level is private, that means it is "file level" private

In Java, if a class is public, its name has to match the file name, i.e there can only be one public class per file
in Kotlin that is not the case, you can have multiple classes per file

OOP
---
// Primary constructor => declared outside the curly braces
class Employee constructor(name: String) {
    val name: String

// init blocks are not constructors, they are used in conjunction with the primary constructor
// primary constructors can not contain code, so you would need to use init blocks (you can have more than one)
    init {
        this.name = name
    }
}

// another way of writing the above - reduction of boilerplate code
class Employee constructor(name: String) {
    val name: String = name
}

// more boilerplate reduction, under the hood, the code gets added
class Employee constructor(val name: String) {
}

// even more boilerplate reduction, remove the "constructor" keyword
class Employee (val name: String) {
}

we would need to add the constructor keyword back if we need to change the visibility of the primary contructor

// SECONDARY CONSTRUCTOR
class Employee(val name: String) {

    var fullTime: Boolean = true

    // 2ndary constructor can not declare members (val or var)
    // also, it must delegate what needs to be delegated to the primary constructor =>" : this(...)"
    constructor(name: String, fullTime: Boolean) : this(name) {
        this.fullTime = fullTime
    }
}

// The kotlin way
class Employee(val name: String, var fullTime: Boolean = true) {...}

PS: primary contructor is not mandatory, simply write the class like you do in Java
PS: default values can also be used in 2ndary constructors

Properties:
-----------
in kotlin, we call member variables and fields: properties
for public properties, we use the dot notation. Under the hood, this is calling the default getters and setters

in kotlin, getters and setters must have the same visibility as their properties
to a private property will have a private getter and a private setter (or ones with less permissive access)
hence it can not be accessed from outside of its class
in Kotlin, we have to think differently: in koltin, it is OK to have public properties

PS: access modifiers can be added in the primary constructor, for example:
class Employee(val name: String, private var fullTime: Boolean = true) {...}

In case we need a custom getter and setter, we will have to declare the properties within the class and not the constructor

in kotlin, if you want a custom set and get, you HAVE to write them directly after the property declaration

    var fullTime = fullTime
        get() {
            println("running the custom get")
            return field // this is called the backing field, this is only generated if we need the value of fullTime
        }
        set(value) {
            println("running the custom set")
            field = value
        }

PS: the constructors do not use the accessor methods under the hood

Constants
---------
val MY_CONTANT = 100 // at the top level of the file
we use val for immutability

Data Classes
------------
a class that is only meant to store state
proprties, setters and getters only

with data classes, we get some nice functions for free
comes with its own toString() function, a custom implementation of the equals() function and a copy() function
=> all of these of course can be overriden
=> any property that is not defined in the primary constructor, will not be taken into account for the methods mentioned above

println(car == car2) // True: data class => by default, it does structural comparision
println(car === car2) // false: different instance

var car4 = car.copy(year = 2016) // copy everything by change value of year property

Condition: there must be a primary constructor and it must contain at least 1 declaration (val or var)
also, anything set in it MUST also be a declaration

they also get: destructuring declaration
data classes also can not be abstract, sealed or inner classes

Functions
---------
// function with block body
fun labelMultiply(x: Int, y: Int, label: String): String {
    return "$label ${x * y}"
}

If all the function is doing is returning the result of an expression, then we can remove more boilerplate code:
// function with an expression body
fun labelMultiply2(x: Int, y: Int, label: String) = "$label ${x * y}"

Void (java) return type: Unit (kotlin)

vararg keyword
--------------
fun printCars(vararg cars: Car) {...}
restriction: we can only have 1 vararg parameter in a function signature
If vararg was not the last parameter in the function signature, then everything that comes after is will need to be
sent while mention the name parameters

val numbers = arrayOf(1,2,3) => arrayOf is actually using a vararg

Spread operator: *
spreads an array into a vararg
val manyCars = arrayOf(car, car2, car3)

// We use the spread operator to spread the array
var moreCars = arrayOf(car2, car3)
val lotsOfCars = arrayOf(manyCars, moreCars, car4) => array containing 2 arrays and an car Object
but we just want an array of cars so:
val lotsOfCars = arrayOf(*manyCars, *moreCars, car4)

extension function
------------------
allows us to extend a class with more functions
this does not mean that encapsulations can be broken

// Classic Way
fun upperFirstAndLast(str: String): String {
        val upperFirst = str.substring(0, 1).uppercase() + str.substring(1)
        return upperFirst.substring(0, upperFirst.length - 1) + upperFirst.substring(
            upperFirst.length - 1,
            upperFirst.length
        ).uppercase()
    }

// to Call: upperFirstAndLast("blabla")

// makes it look like the function belongs to the String class
fun String.upperFirstAndLast(): String {
    val upperFirst = this.substring(0, 1).uppercase() + this.substring(1)
    return upperFirst.substring(0, upperFirst.length - 1) + upperFirst.substring(
        upperFirst.length - 1,
        upperFirst.length
    ).uppercase()
}

// to Call: "blabla".upperFirstAndLast()
What we did here is that we preceded the function name with what we call the receiver type
and "blabla" is the receiver Object
=> we can also drop the use of "this":
val upperFirst = this.substring(0, 1).uppercase() + this.substring(1)
val upperFirst = substring(0, 1).uppercase() + substring(1)

Inline Function
---------------
compiled to its body and NOT a function call
mostly used when dealing with lambdas
inline fun myFun(...) {...}

Inheritance
-----------
in kotlin, everything is final and public by default

// we use the keyword open: to make a class non-final
open class Printer {

}

// we call the default primary constructor
class LaserPrinter : Printer() {

}

// we call the default primary constructor
class LaserPrinter2() : Printer() {

}

// we use a secondary constructor and differ to super()
class LaserPrinter3 : Printer {
    constructor(): super()

}

the same rule for open and abstract applies to functions that we are trying to override
because, of course, in kotlin, everything is final by default, for example:

// we use the keyword open: to make a class non-final
open abstract class Printer(val modelName: String) {
    // after adding abstract => we can remove the open keyword: it becomes redundant
    open fun printModel() = println("the model name is: $modelName")

    // declaring an abtract method
    abstract fun bestSellingPrice(): Double
}

class LaserPrinter(modelName: String) : Printer(modelName) {
    override fun printModel() = println("the new output is: $modelName")
    override fun bestSellingPrice(): Double = 129.99
}

Now, in case we want to make a function un-overridable, we have to explicitly use the keyword final
in addition to abstract, the override keyword implicitly includes the keyword open, so once you override something, you are saying it is open
and it can be overriden

NOTE: you can not call a super 2ndary constructor from a subclass, all MUST delegate to the primary constructor.
thus the only way to do such a thing would be if the parent did not have a primary constructor defined

Data classes are closed, they can not be extended, but they can extend other classes (since kotlin 1.1)
in Kotlin 1.1, they became able to also contain classes

Interfaces
----------
interface MyInter {
    val number: Int // can not be initialized here
    fun myString(str: String): String
}

interface MySubInter: MyInter {
    fun mySubString(str: String): String
}

no need to use keyowrds open and abstract here, these are abstract anyway

// We can ofcourse implement multiple interfaces
class SomethingElse: MyClass, MyInter, MyInter2 {
    override val number: Int = 25

    override fun myString(str: String): String {
        TODO("Not yet implemented")
    }

    override fun myString2(str: String): String {
        TODO("Not yet implemented")
    }
}

in interfaces, we can have properties (they do not need to be abtract)
and we can also provide accessors for them that we can override in subinterfaces or classes that implement said interfaces
the property will have to be initialized ofcourse in the class

in order to give our interface property a default value, we use a custom get:

interface MyInter {
    val number: Int // can not be initialized here
        get() {
            return number * 100
            // or return 25 => now we can call this concrete property
            // in this case, there will be no need to override it
        }
    fun myString(str: String): String
}

interface MyInter {
    val number: Int
    val number2: Int
        get() = 25
    val number3: Int
        get() {
            return 25
        }
    fun myString(str: String): String
}

NOTE: interface properties do not have backing fields

Singletons
----------
We use the keyowrd "object" instead of class
has no constructors
object keyword => creates and constructs

fun main(args: Array<String>){
    println(CompComs.getTagLine())
    println(CompComs.getCopyRightLine())
}


object CompComs {
    val currentYear = Year.now().value
    fun getTagLine() = "our company rocks!"
    fun getCopyRightLine() = "blabla \u00A9 $currentYear blabla"
}

=> one single instance is created the 1st time the class is used
NOTE: Singletons can extend other classes or implement interfaces

Companion Objects
-----------------
Static keywords in kotlin do not exist
=> we would use top level (file level) functions for example

class SomeClass {
    private var privateVar = 6
    fun accessPrivateVar(){
        println(privateVar)
    }

// We can thing of everything inside the companion object as static
    companion object {
        private var privateVar2 = 7
        fun accessPrivateVar(){
            println(privateVar2)
        }
    }
}

to call the functions then:
SomeClass.accessPrivateVar2() // using the class without instanciating it
SomeClass.Companion.accessPrivateVar2()

companion object bla {... we can also give it a name "bla"
so... SomeClass.bla.accessPrivateVar2() 

Companion objects can be used to access private constructors
thus they can be used to implement the factory pattern

// We make the primary constructor private => note: a primary constructor is not a requirment for this, can be done with 2ndary ones wihout a primary one
class SomeFactoryClass private constructor(val someString: String) {
//    val someString: String
//
//    private constructor(str: String) {
//        someString = str
//    }
//
//    constructor(str: String, lowerCase: Boolean) {
//        if (lowerCase) {
//            someString = str.lowercase()
//        } else {
//            someString = str.uppercase()
//        }
//    }

    companion object {
        fun justAssign(str: String) = SomeFactoryClass(str)

        fun upperOrLowerCase(str: String, lowerCase: Boolean): SomeFactoryClass {
            if (lowerCase) {
                return SomeFactoryClass(str.lowercase())
            } else {
                return SomeFactoryClass(str.uppercase())
            }
        }
    }
}

Anonymous object | Anonymous expressions
----------------------------------------
every time we call it, we have to provide an implementation for the function
also, these implementations have access to the variables around them, like the 2nd call below accessing "var" thisIsMutable and not a "val" (which is final)

fun main(args: Array<String>) {
    wantsSomeInterface(object : SomeInterface {
        override fun mustImplement(num: Int) = "this is from mustImplement my int: ${num * 100}"
    })

    var thisIsMutable = 45

    wantsSomeInterface(object : SomeInterface {
        override fun mustImplement(num: Int): String{
            thisIsMutable++  
            return "this is from mustImplement my int: ${num * 100}"
        }
    })
}


interface SomeInterface {
    fun mustImplement(num: Int): String
}

fun wantsSomeInterface(si: SomeInterface) {
    println("printing from SomeInterface ${si.mustImplement(22)}")
}

we can all have multiple interfaces:
wantsSomeInterface(object : SomeInterface, SomeInterface2, SomeInterface3... etc

Enums
-----
Very similar to Java
enum class Department2(val fullName: String, val numEmployees: Int) {
    HR("hr", 5),
    IT("it", 7),
    ACCOUNTING("acc", 12),
    SALES("sal", 20);

    fun getDepInfo() = "$fullName and $numEmployees"
}

READ MORE HERE: https://www.baeldung.com/kotlin/enum#overview

imports
-------
imports in kotlin do not have to match to directory structure the same way file names do not have to match the class name
for example, at the top of the file, you can have
package bla.blo.bli
while the folder names are bla -> blo -> juju
will still work fine

Recommended Way: do it like java, conserve the directory structure

If we are dealing with another module (not a package), we will need to add the module as dependency from the project's settings
then, we will be able to import from its files

for enums, we actually import an individual enum, but usually, we would want to import the entire class
enums can be aliased, using "as":
import bla.blo.bli.SomeClass as blu

as can be used with functions as well

extension functions have to be imported if we want to use them in other files

Internal Access modifier
------------------------
"internal" access modifier make a top level function for example accessible from any other file in the same module
BUT files in other modules, even if the file with the internal function is being imported, can not access it

Loops, IF, When and Try/Catch
=============================
Loops
-----
The classic Java for loop is not available in Kotlin
in kotlin, we use ranges, and the start and end are inclusive

val range = 1..5
val range = 'a'..'z'
val range = "ABC".."XYZ"

=> any type that is "Comparable" can be used in a range
that is because of the "in" operator which is used by the loop

val backwardsRange = 5.downTo(1) // OK
val backwardsRange2 = 5..1 // backwards rand this way does not work
this translates to 5 <= x <= 1: as a logical statement, this is alwasy false

// another way of reversing a range to go backwards
val reversedRange = range.reversed()
most of these methods can only be used with numerical and char ranges

val rangWithSteps = 3..15
val stepThree = rangWithSteps.step(3) // returns a range
you can write it like this: val rangWithSteps = (3..15).step(3)
or like this: val rangWithSteps4 = 3..15 step 4

// another way of reversing a range to go backwards
val reversedRange = range.reversed()

String ranges do not have an interator defined on them
val range = "ABC".."XYZ" => can contain values like "CCC" and "CCCCCCCCCCCCCC" (comparison happens one char at a time)

Strings however have iterators defined on them:
val str = "hello"
for (c in str) {
    println(c)
}

// loop with step size
for (num in 1..20 step 4) {
        println(num)
}

// loop backwards with step size
for (num in 20 downTo 15 step 2) {
    println(num)
}

you can use the keyweird "until", it excludes the final element in the range

val range = 0..str.length

we can also use !in => not in with strings, numbers and chars

val seasons = arrayOf("spring", "summer", "autumn", "fall")
seasons.forEach { println(it) }
seasons.forEachIndexed { index, value -> println("$index is $value") }
for (index in seasons.indices) {
    println("$index is ${seasons[index]}")
}

for (i in 1..3) {
    println(i)
    jloop@ for (j in 1..4) { // we can give loops a name
        println(j)
        for (k in 1..10) {
            println(k)
            if (k == 7) {
                break; // breaks only the k loop
                // if we want to break as the jloop, we 1st give it a name then
                // break@jloop;
                // also works with continue
            }
        }
    }
}

IF statement
------------
ifs can have a return value

// turnary operator does not exist in kotlin
val z = if (x == 5) 6 else 7

val v = if (x == 5) {
    println(x)
    6
} else {
    println("bla")
    7
}

when the IF returns a value, it is an expression
when it does not, it is a statement

// can also be nested in string templates
println("blabla ${if (x == 5) 6 else 7}")

When
----
x = 600
when (x) {
    100 -> println(100)
    200, 600 -> println(200) // we can have multiple cases
    300 -> println(200)
    else -> println("no match")
}

x = 220
when (x) {
    100 -> println(100)
    in 200..250 -> println("in range") // we can have ranges
    300 -> println(200)
    else -> println("no match")
}

x = 330
val y = 30
when (x) {
    100 -> println(100)
    in 200..250 -> println("in range")
    300 + y -> println(300) // we can also use expressions
    else -> println("no match")
}

// Smart casting in play
when (something) {
    is String -> println(something.uppercase()) // smart casting happening here: type is Any, but compiler knows it is a String because of condition check
    is BigDecimal -> println("big D")
}

we can also have

val z = when (something) {
    is String -> println(something.uppercase()) // smart casting happening here: type is Any, but compiler knows it is a String because of condition check
    is BigDecimal -> println("big D")
    else -> print("bla") // else here is mandatory, z MUST have a value, in this case the return value will be "Unit"
}

we can have retur values:
val z = when (something) {
    is String -> { 
            println(something.uppercase())
            1 // this would be the return value if "something" was a string: return value must allways be the last line
    } 
    is BigDecimal -> println("big D")
    else -> print("bla") // else here is mandatory, z MUST have a value, in this case the return value will be "Unit"
}

When userd with enums:
val season = Season.FALL
val str = when (season) {
    Season.FALL -> "it is fall"
    Season.SUMMER -> "it is summer"
    else -> "dunno man" // if all the possible enum values are listed, then the else would not be needed
}

println(str)

"when" can be used as an alternative to if else => used without an input value
when {
    x < y -> do this
    x == y -> dot that
    else -> finish it
}

Try / Catch
-----------

fun getNumber(str: String): Int {
    // like other blocks, the last expression's value can serve as a return value
    return try {
        Integer.parseInt(str) // returns the result of this
    } catch (ex: NumberFormatException) {
        0 // returns zero
    } finally { // like java, always executes
        println("finally!")
    }
}

// nullable return type
fun getNumber2(str: String): Int? {
    // like other blocks, the last expression's value can serve as a return value
    return try {
        Integer.parseInt(str) // returns the result of this
    } catch (ex: NumberFormatException) {
        null
    } finally { // like java, always executes
        println("finally bla!")
    }
}

// re-throw / chain exception
fun getNumber3(str: String): Int {
    // like other blocks, the last expression's value can serve as a return value
    return try {
        Integer.parseInt(str) // returns the result of this
    } catch (ex: NumberFormatException) {
        throw IllegalArgumentException("twas bad bro", ex)
    } finally { // like java, always executes
        println("finally bla!")
    }
}

Use case for "Nothing" type
here, we know the function below, in its current state, that it will return nothing, so we use return type "Nothing"
fun notImplementedYet(something: String): Nothing {
    throw IllegalArgumentException("implement me!")
}